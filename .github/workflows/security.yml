name: Security Check

on:
  pull_request:

permissions: {}

jobs:
  kairo:
    runs-on: ${{ vars.KAIRO_RUNNER_LABELS && fromJson(vars.KAIRO_RUNNER_LABELS) || 'ubuntu-latest' }}
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Run Kairo Security Check
        env:
          KAIRO_API_KEY: ${{ secrets.KAIRO_API_KEY }}
          KAIRO_API_URL: ${{ vars.KAIRO_API_URL }}
          KAIRO_FAIL_OPEN: ${{ vars.KAIRO_FAIL_OPEN }}
          KAIRO_HOSTS_ENTRY: ${{ vars.KAIRO_HOSTS_ENTRY }}
          KAIRO_ENABLED: ${{ vars.KAIRO_ENABLED }}
        shell: bash
        run: |
          set -euo pipefail

          # Default behavior: do not block PRs unless explicitly enabled.
          KAIRO_ENABLED="${KAIRO_ENABLED:-false}"
          if [[ "$KAIRO_ENABLED" != "true" ]]; then
            echo "::warning::Kairo security check is disabled (set repo variable KAIRO_ENABLED=true to enable). Skipping."
            exit 0
          fi

          if [[ -z "${KAIRO_API_KEY:-}" ]]; then
            echo "::warning::KAIRO_API_KEY secret is not set. Skipping Kairo security check."
            exit 0
          fi

          KAIRO_API_URL="${KAIRO_API_URL:-https://api.kairoaisec.com/v1/analyze}"
          KAIRO_FAIL_OPEN="${KAIRO_FAIL_OPEN:-false}"

          if [[ -n "${KAIRO_HOSTS_ENTRY:-}" ]]; then
            echo "$KAIRO_HOSTS_ENTRY" | sudo tee -a /etc/hosts >/dev/null
          fi

          sudo apt-get update -y
          sudo apt-get install -y jq

          TMP_OBJS="$(mktemp)"
          : > "$TMP_OBJS"

          # Collect a reasonable set of tracked, text-like files only.
          git ls-files -z \
            | while IFS= read -r -d '' f; do
                [[ -f "$f" ]] || continue

                case "$f" in
                  *.sol|*.toml|*.md|*.yml|*.yaml|*.json|*.txt|*.env.example|.env.example)
                    ;;
                  *)
                    continue
                    ;;
                esac

                # Skip very large files to avoid API/request limits.
                size="$(wc -c < "$f" | tr -d '[:space:]')"
                [[ "$size" -le 200000 ]] || continue

                jq -Rs --arg path "$f" '{path: $path, content: .}' < "$f" >> "$TMP_OBJS"
              done

          REQUEST_FILE="$(mktemp)"
          jq -s '{source: {type: "inline", files: .}}' "$TMP_OBJS" > "$REQUEST_FILE"

          RESPONSE_FILE="$(mktemp)"
          set +e
          HTTP_CODE="$(
            curl -sS -o "$RESPONSE_FILE" -w "%{http_code}" \
              --retry 3 --retry-all-errors --connect-timeout 10 --max-time 300 \
              -X POST "$KAIRO_API_URL" \
              -H "Authorization: Bearer ${KAIRO_API_KEY}" \
              -H "Content-Type: application/json" \
              --data-binary @"$REQUEST_FILE"
          )"
          CURL_EXIT="$?"
          set -e

          if [[ "$CURL_EXIT" -ne 0 ]]; then
            if [[ "$CURL_EXIT" -eq 6 ]]; then
              if [[ "${KAIRO_FAIL_OPEN}" == "true" ]]; then
                echo "::warning::Could not resolve host for KAIRO_API_URL ($KAIRO_API_URL). Skipping security check because KAIRO_FAIL_OPEN=true."
                exit 0
              fi
              echo "::error::Could not resolve host for KAIRO_API_URL ($KAIRO_API_URL). If this is an internal/non-public domain, use a self-hosted runner or set repo variable KAIRO_API_URL to a publicly resolvable endpoint. To avoid blocking PRs, set repo variable KAIRO_FAIL_OPEN=true."
            else
              if [[ "${KAIRO_FAIL_OPEN}" == "true" ]]; then
                echo "::warning::curl failed (exit $CURL_EXIT) calling KAIRO_API_URL ($KAIRO_API_URL). Skipping security check because KAIRO_FAIL_OPEN=true."
                exit 0
              fi
              echo "::error::curl failed (exit $CURL_EXIT) calling KAIRO_API_URL ($KAIRO_API_URL). To avoid blocking PRs, set repo variable KAIRO_FAIL_OPEN=true."
            fi
            exit 1
          fi

          RESPONSE="$(< "$RESPONSE_FILE")"
          echo "$RESPONSE" | jq -C . || true

          if [[ "$HTTP_CODE" -ge 400 ]]; then
            echo "::error::Kairo API request failed with HTTP $HTTP_CODE"
            exit 1
          fi

          DECISION="$(echo "$RESPONSE" | jq -r '.decision // empty')"
          if [[ "$DECISION" == "BLOCK" ]]; then
            echo "::error::Security check failed"
            exit 1
          fi
